input {
    beats {
        port => 5044 ## Reads Filebeat outputs
    }
}

filter {

    if "starling-logs" in [tags] {
        # Format Starling Wifi logs.

        grok {
            match => { "message" => [
               "\[%{TIMESTAMP_ISO8601:timestamp}\] %{DATA:env}\.%{DATA:severity}: %{GREEDYDATA:context}", # For standard logs.
               "\[%{DATA:prevexception}\] %{GREEDYDATA:context}" # For logs starting with [previous exception]
           ]}
        }

        # Some laravel logs starts like [previous exception] ... without timestamps or anything.
        # For that case we dont touch @timestamp so that, Elastic can stack them as normal logs with others.
        # Note that: @timestamp in those logs corresponds to moment logstash pushed them to elastic, not actual log timestamp.
        if ![prevexception] {
            # Rename logstash generated @timestamp as read_timestamp to keep push-time in log.
            mutate {
                rename => { "@timestamp" => "read_timestamp" }
            }

            # Make sure timestamp is formatted correctly.
            date {
                match => [ "timestamp", "YYYY-MM-dd HH:mm:ss" ]
                remove_field => "timestamp"
            }
        }

        # Remove message field after parsing it.
        # Add index prefix.
        mutate {
            add_field => { "logtype" => "starling-logs"}
            remove_field => [ "message" ]
        }

    } else if "mysql-logs" in [tags] {

        # Format MySQL error logs.

        grok {
            match => { "message" => [
                "%{DATA:timestamp} %{NUMBER:tid} \[%{DATA:severity}\] %{GREEDYDATA:context}", # For standard logs.
                "%{GREEDYDATA:context}" # For logs not in standard format.
            ]}
        }

        if [timestamp] {
            # Note: Check explanations on starling-wifi filter.
            mutate {
                rename => { "@timestamp" => "read_timestamp" }
            }

            # MySQL has messy timestamp formats in the logs. Before 12 o'clock, hour does not contain zero-padding on the left.
            # That's why we use two matching to make sure.
            date {
                match => [ "timestamp", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd  H:mm:ss" ]
                remove_field => "timestamp"
            }
        }

        # Remove message field after parsing it.
        # Add index prefix.
        mutate {
            add_field => { "logtype" => "mysql-logs"}
            remove_field => [ "message" ]
        }

    } else if "nginx-logs" in [tags] {

        # Format Nginx error logs.

        grok {
            match => { "message" => "%{DATA:timestamp} \[%{DATA:severity}\] %{NUMBER:pid}#%{NUMBER:tid}: (\*%{NUMBER:connectionId} )?%{GREEDYDATA:context}" }
        }

        # Note: Check explanations on starling-wifi filter.
        mutate {
            rename => { "@timestamp" => "read_timestamp" }
        }

        # Make sure to format timestamp correctly.
        date {
            match => [ "timestamp", "YYYY/MM/dd H:m:s" ]
            remove_field => "timestamp"
        }

        # Remove message field after parsing it.
        # Add index prefix.
        mutate {
            add_field => { "logtype" => "nginx-logs"}
            remove_field => [ "message" ]
        }

    } else if "radius-logs" in [tags] {

        # Format FreeRadius logs.

        grok {
            patterns_dir => ["/usr/share/logstash/pipeline/patterns"]
            match => { "message" => [
                "%{FREERADIUS_DATE:timestamp} : %{DATA:severity}: rlm_sql \(%{DATA:db_name}\): %{GREEDYDATA:context}",
                "%{FREERADIUS_DATE:timestamp} : %{DATA:severity}: %{GREEDYDATA:context}"
            ]}
        }

        # Note: Check explanations on starling-wifi filter.
        mutate {
            rename => { "@timestamp" => "read_timestamp" }
        }

        # Make sure to format timestamp correctly.
        date {
            match => [ "timestamp", "EEE MMM dd HH:mm:ss yyyy" ] # Thu Aug 27 06:43:15 2020
            remove_field => "timestamp"
        }

        mutate {
            add_field => { "logtype" => "radius-logs"}
            remove_field => [ "message" ]
        }

    } else if "raddact-logs" in [tags] {

        # Format radactt logs.


        mutate {
            add_field => { "logtype" => "radactt-logs"}
            remove_field => [ "message" ]
        }

    }
}

output {

    stdout {
        codec => rubydebug
    }

    elasticsearch {
        hosts => "elasticsearch:9200"
        manage_template => false
        index => "%{logtype}-%{+YYYY.MM.dd}"
#        user => "elastic"
#        password => "changeme"
    }
}